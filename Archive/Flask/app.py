# This code in this file was generated by OpenAI's Chat GPT (January 2025)

from flask import Flask, request, jsonify
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from datetime import datetime
import joblib
from flask_cors import CORS

import sklearn
print(sklearn.__version__)

app = Flask(__name__)
CORS(app)  

# Load model here 
rf_model = joblib.load("../Weather/weather_regressor.pkl")
# print(f"Type of rf_model: {type(rf_model)}")

# Default values
default_location = 'Anaheim'
default_tmin = 65  
default_tmax = 78  

locations = ['Anaheim']  # Add other locations to this list if needed

def preprocess_input(date_str, location, tmin, tmax):
    # Encode the location as a binary vector
    binary_features = [1 if loc == location else 0 for loc in locations]
    
    # Convert the date to ordinal
    date_num = pd.to_datetime(date_str).date()
    date_ord = date_num.toordinal()
    
    # Combine all features into a single array for prediction
    input_features = np.array([[date_ord] + binary_features + [tmin, tmax]])
    
    print(input_features)
    return input_features
    

@app.route('/predict', methods=['GET'])
def predict():
    # Get the input data from the request, with a default for missing parameters
    date = request.args.get('date')  # Date is required
    location = request.args.get('location', default_location)  # Default to 'Anaheim'
    tmin = float(request.args.get('tmin', default_tmin))  # Default to 60 °F if not provided
    tmax = float(request.args.get('tmax', default_tmax))  # Default to 80 °F if not provided
    
    # Ensure the date is provided (otherwise return an error)
    if not date:
        return jsonify({'error': 'Date parameter is required'}), 400

    # Preprocess input and predict
    input_features = preprocess_input(date, location, tmin, tmax)
    prediction = rf_model.predict(input_features)
    
    # Return the prediction as a JSON response
    return jsonify({'prediction': round(prediction[0],2)})


if __name__ == '__main__':
    app.run(debug=True)
